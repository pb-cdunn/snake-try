def snake_merge_dynamic(output_fn, input_fns, pattern):
        """Assume '{key}' is the only wildcard in pattern.
        """
        re_dynamic = re.compile(pattern.replace('{key}', '(\S)'))
        outdir = os.path.normpath(os.path.dirname(output_fn))
        mapped = dict()
        for fn in input_fns:
            mo = re_dynamic.search(fn)
            assert mo, '{!r} did not match {!r}'.format(fn, re_dynamic.pattern)
            key = mo.group(1)
            mapped[key] = os.path.relpath(fn, outdir)
        ser = json.dumps(mapped) + '\n'
        with open(output_fn, 'w') as out:
            out.write(ser)

rule all:
    input: 'mapped_outputs.json'

rule clean:
    shell: 'rm input_* intermediate_* output.txt'

rule merge:
    input: ancient(dynamic('intermediate_{key}.txt'))
    output: 'mapped_outputs.json'
    run:
        snake_merge_dynamic(output[0], [str(i) for i in input], 'intermediate_{key}.txt')

rule parallel:
    input: 'input_{key}.txt'
    output: 'intermediate_{key}.txt'
    shell: 'cat {input} > {output} && sleep 1 && echo processed >> {output}'

rule split:
    input: 'mapped_inputs.json'
    output: dynamic('input_{key}.txt')
    shell: '../symlink_mapped.py --mapped={input} --fn-pattern="input_{{}}.txt"'

rule map_inputs:
    input: '../input.txt'
    output: 'mapped_inputs.json'
    shell: '../dump_mapped_inputs.py --mapped={output} --input={input}'
