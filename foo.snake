#import json, os, re

def snake_merge_dynamic(output_fn, input_fns, pattern):
        """Assume '{key}' is the only wildcard in pattern.
        """
        re_dynamic = re.compile(pattern.replace('{key}', '(\S)'))
        outdir = os.path.normpath(os.path.dirname(output_fn))
        if not os.path.isdir(outdir):
            os.makedirs(outdir)
        mapped = dict()
        for fn in input_fns:
            mo = re_dynamic.search(fn)
            assert mo, '{!r} did not match {!r}'.format(fn, re_dynamic.pattern)
            key = mo.group(1)
            mapped[key] = os.path.relpath(fn, outdir)
        ser = json.dumps(mapped, indent=2, separators=(',', ': ')) + '\n'
        with open(output_fn, 'w') as out:
            out.write(ser)

rule all:
    input: 'merge/mapped_outputs.json'

rule merge:
    input: ancient(dynamic('parallel_outputs/{key}/intermediate_{key}.txt'))
    output: 'merge/mapped_outputs.json'
    run:
        snake_merge_dynamic(output[0], [str(i) for i in input], 'parallel_outputs/{key}/intermediate_{key}.txt')

rule parallel:
    input: 'parallel_inputs/{key}/input_{key}.txt'
    output: 'parallel_outputs/{key}/intermediate_{key}.txt'
    params:
        reltopdir='../..'
    shell: '''
set -vx
outdir=$(dirname {output[0]})
#mkdir -p ${{outdir}}
cd ${{outdir}}

cat {params.reltopdir}/{input} > {params.reltopdir}/{output}
sleep 1
echo processed >> {params.reltopdir}/{output}

cd -
'''

rule split:
    input: '../input.txt'
    output: 'split/special_split_inputs.json'
    params:
        reltopdir='..'
    shell: '''
set -vx
outdir=$(dirname {output[0]})
#mkdir -p ${{outdir}}
cd ${{outdir}}

../{params.reltopdir}/special_split_inputs.py --special-split={params.reltopdir}/{output} --input={params.reltopdir}/{input}

cd -
'''

rule split_dynamic:
    input: rules.split.output[0]
    output: dynamic('parallel_inputs/{key}/input_{key}.txt')
    shell: '../symlink_mapped.py --special-split={input} --fn-pattern="parallel_inputs/{{key}}/input_{{key}}.txt"'
